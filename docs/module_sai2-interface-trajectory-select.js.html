<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: module/sai2-interface-trajectory-select.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: module/sai2-interface-trajectory-select.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Defines a custom HTML element to model and execute Catmull-Rom
 * trajectory generation.
 * &lt;pre>
 * Element Tag: &amp;lt;sai2-interface-trajectory-select&amp;gt;
 * HTML attributes:
 *    xLim: number[] - array of [x min, x max]
 *    yLim: number[] - array of [y min, y max]
 *    zLim: number[] - array of [z min, z max]
 *    current_pos_key: string - Redis key containing the current EE pos
 * &lt;/pre>
 * 
 * @module ./module/sai2-interface-trajectory-slider
 */

import { registerWindowResizeCallback } from '../resize.js';
import { get_redis_val } from '../redis.js';

const template = document.createElement('template');
template.innerHTML = `
  &lt;style>
    .sai2-interface-trajectory-select-top {
      display: flex;
      flex-direction: column;
      height: 95%;
    }

    .sai2-interface-trajectory-select-top .metadata {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: 1fr 1fr auto auto;
      grid-template-areas:
        "trajectory-params"
        "trajectory-buttons"
        "point-remover"
        "trajectory-info";
    }

    .sai2-interface-trajectory-select-top .metadata > div {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: space-around;
    }

    .sai2-interface-trajectory-select-top .metadata .trajectory-params {
      grid-area: trajectory-params;
      display: grid;
      grid-template-rows: 1fr auto;
      grid-template-columns: 1fr;
    }

    .sai2-interface-trajectory-select-top .metadata .trajectory-params > div {
      display: flex;
      justify-content: space-around;
    }

    .sai2-interface-trajectory-select-top .error-message {
      color: red;
    }

    .sai2-interface-trajectory-select-top .metadata .trajectory-buttons {
      grid-area: trajectory-buttons;
    }

    .sai2-interface-trajectory-select-top .metadata .point-remover {
      grid-area: point-remover;
    }

    .sai2-interface-trajectory-select-top .metadata .trajectory-info {
      grid-area: trajectory-info;
    }

    .sai2-interface-trajectory-select-top .plots {
      flex: 9;
    }  
  &lt;/style>
	&lt;div class="sai2-interface-trajectory-select-top">
    &lt;div class="metadata">
      &lt;div class="trajectory-params">
        &lt;div>
          &lt;label>Trajectory Duration&lt;/label>
          &lt;input class="traj-max-time" type="number" min="0.1" step="0.1">
          &lt;label>Trajectory Step Size&lt;/label>
          &lt;input class="traj-step-time" type="number" min="0.01" step="0.01">
        &lt;/div>
        &lt;div>
          &lt;label class="error-message">&lt;/label>
        &lt;/div>
      &lt;/div>
      &lt;div class="trajectory-buttons">
        &lt;button class="trajectory-add-pt-btn">Add Point&lt;/button>
        &lt;button class="trajectory-get-btn">Get Trajectory&lt;/button>
        &lt;button class="trajectory-clear-btn">Clear Trajectory&lt;/button>
        &lt;button class="trajectory-run-btn">Run Trajectory&lt;/button>
      &lt;/div>
      &lt;select class="point-remover chosen_select" multiple data-placeholder="Add a point...">&lt;/select>
      &lt;div class="trajectory-info">
        &lt;div>
          &lt;h4>Max Velocity: &lt;/h4>
          &lt;label>Norm: &lt;/label>
          &lt;label class="max-vel-norm">&lt;/label>
          &lt;label>X: &lt;/label>
          &lt;label class="max-vel-x">&lt;/label>
          &lt;label>Y: &lt;/label>
          &lt;label class="max-vel-y">&lt;/label>
          &lt;label>Z: &lt;/label>
          &lt;label class="max-vel-z">&lt;/label>
        &lt;/div>
        &lt;div>
          &lt;h4>Max Acceleration:&lt;/h4>
          &lt;label>Norm: &lt;/label>
          &lt;label class="max-accel-norm">&lt;/label>
          &lt;label>X: &lt;/label>
          &lt;label class="max-accel-x">&lt;/label>
          &lt;label>Y: &lt;/label>
          &lt;label class="max-accel-y">&lt;/label>
          &lt;label>Z: &lt;/label>
          &lt;label class="max-accel-z">&lt;/label>
        &lt;/div>
      &lt;/div>
    &lt;/div>
    &lt;div class="grid-half">
      &lt;div class="col traj-xy">&lt;/div>
      &lt;div class="col traj-xz">&lt;/div>
    &lt;/div>
  &lt;/div>
`;
    
customElements.define('sai2-interface-trajectory-select', class extends HTMLElement {
  constructor() {
    super();
    this.template = template;

    this.xy_plot = null;
    this.xy_config = null;

    this.xz_plot = null;
    this.xz_config = null;

    this.points = { x: [], y: [], z: [], idx: [] };
    this.trajectory = { x: [], y: [], z: [], t:[], v: [], a: [] };
    this.ee_pos = { x: [], y: [], z: []};
    this.next_point_index = 1; // point 0 is reserved for EE
  }

  connectedCallback() {
    // get DOM elements
    let template_node = this.template.content.cloneNode(true);
    let xy_div = template_node.querySelector('.traj-xy');
    let xz_div = template_node.querySelector('.traj-xz');

    // top level UI items
    let addPointButton = template_node.querySelector('.trajectory-add-pt-btn');
    let getTrajectoryButton = template_node.querySelector('.trajectory-get-btn');
    let clearTrajectoryButton = template_node.querySelector('.trajectory-clear-btn');
    let runTrajectoryButton = template_node.querySelector('.trajectory-run-btn');
    let pointSelect = template_node.querySelector('.point-remover');
    let trajectoryMaxTimeInput = template_node.querySelector('.traj-max-time');
    let trajectoryStepSizeInput = template_node.querySelector('.traj-step-time');
    let errorMessageLabel = template_node.querySelector('.error-message');

    // max vel &amp; accel UI items
    let maxVelNorm = template_node.querySelector('.max-vel-norm');
    let maxVelX = template_node.querySelector('.max-vel-x');
    let maxVelY = template_node.querySelector('.max-vel-y');
    let maxVelZ = template_node.querySelector('.max-vel-z');
    let maxAccelNorm = template_node.querySelector('.max-accel-norm');
    let maxAccelX = template_node.querySelector('.max-accel-x');
    let maxAccelY = template_node.querySelector('.max-accel-y');
    let maxAccelZ = template_node.querySelector('.max-accel-z');

    // grab passed-in attributes
    let xLim = JSON.parse(this.getAttribute('xLim'));
    let yLim = JSON.parse(this.getAttribute('yLim'));
    let zLim = JSON.parse(this.getAttribute('zLim'));
    let current_ee_pos_key = this.getAttribute('current_pos_key');

    let primitive_key = "sai2::examples::primitive";
    let primitive_value = "primitive_trajectory_task";
    let position_key = "sai2::examples::desired_position";
    let velocity_key = "sai2::examples::desired_velocity";

    // initialize template
    this.default_config = {
      grid: {},
      xAxis: { type:'value', name: 'x', min: xLim[0], max: xLim[1] }, 
      legend: { type: 'scroll' },
      toolbox: {
        top: 'bottom',
        left: 'right',
        feature: {
          saveAsImage: { title: 'Save Plot'},
          dataZoom: { title: { zoom: 'Box Zoom', back: 'Reset View' } }
        }
      },
      dataset: [
        { source: this.points },
        { source: this.trajectory },
        { source: this.ee_pos }
      ]
    };

    // initialize select
    $('.point-remover').chosen({ width: '100%' });

    // initialize empty plot &amp; templates
    this.xy_plot = echarts.init(xy_div);
    this.xz_plot = echarts.init(xz_div);

    this.xy_config = {...this.default_config};
    this.xz_config = {...this.default_config};

    // initialize tooltips
    // series 0, 2 are the control points - 2 is just the EE
    // series 1 is the computed trajectory
    this.xy_config.tooltip = { 
      triggerOn: 'none',
      formatter: params => {
        if (params.seriesIndex === 0 || params.seriesIndex === 2)
          return `Point ${this.points.idx[params.dataIndex]}
            &lt;br>X: ${this.points.x[params.dataIndex]}
            &lt;br>Y: ${this.points.y[params.dataIndex]}`;
        else
          return `Time ${this.trajectory.t[params.dataIndex].toFixed(4)}
            &lt;br>X: ${this.trajectory.x[params.dataIndex].toFixed(3)}
            &lt;br>Y: ${this.trajectory.y[params.dataIndex].toFixed(3)}
            &lt;br>V: ${this.trajectory.v[params.dataIndex].toFixed(3)}
            &lt;br>A: ${this.trajectory.a[params.dataIndex].toFixed(3)}`;
      }
    };

    this.xz_config.tooltip = { 
      triggerOn: 'none',
      formatter: params => {
        if (params.seriesIndex === 0 || params.seriesIndex === 2)
          return `Point ${this.points.idx[params.dataIndex]}
            &lt;br>X: ${this.points.x[params.dataIndex].toFixed(3)} 
            &lt;br>Z: ${this.points.z[params.dataIndex].toFixed(3)}`;
        else
          return `Time ${this.trajectory.t[params.dataIndex].toFixed(4)}
            &lt;br>X: ${this.trajectory.x[params.dataIndex].toFixed(3)}
            &lt;br>Z: ${this.trajectory.z[params.dataIndex].toFixed(3)}
            &lt;br>V: ${this.trajectory.v[params.dataIndex].toFixed(3)}
            &lt;br>A: ${this.trajectory.a[params.dataIndex].toFixed(3)}`;
      }
    };
    
    // series definition
    // control point shapes are defined by initialize_graphics
    // since we need more control than the default
    this.xy_config.series = [{
        id: 'xy',
        type: 'line',
        datasetIndex: 0,
        lineStyle: { type: 'dashed' },
        encode: { x: 'x', y: 'y' },
        symbolSize: false
      }, {
        id: 'xy-traj',
        type: 'line',
        datasetIndex: 1,
        encode: { x: 'x', y: 'y'},
        symbolSize: false,
        lineStyle: { color: 'blue' }
      }, {
        id: 'ee-pos-xy-traj',
        type: 'line',
        datasetIndex: 2,
        symbolSize: 24,
        encode: { x: 'x', y: 'y'},
        symbol: 'pin',
        itemStyle: { color: '#000'}
      }
    ];

    this.xz_config.series = [{
        id: 'xz',
        type: 'line',
        datasetIndex: 0,
        lineStyle: {type: 'dashed'},
        encode: { x: 'x', y: 'z' },
        symbolSize: false,
      }, {
        id: 'xz-traj',
        type: 'line',
        datasetIndex: 1,
        encode: { x: 'x', y: 'z'},
        symbolSize: false,
        lineStyle: { color: 'blue' }
      }, {
        id: 'ee-pos-xy-traj',
        type: 'line',
        datasetIndex: 2,
        symbolSize: 24,
        encode: { x: 'x', y: 'z'},
        symbol: 'pin',
        itemStyle: { color: '#000'}
      }
    ];

    this.xy_config.yAxis = { type:'value', name: 'y', min: yLim[0], max: yLim[1] };
    this.xz_config.yAxis = { type:'value', name: 'z', min: zLim[0], max: zLim[1] };

    this.xy_plot.setOption(this.xy_config);
    this.xz_plot.setOption(this.xz_config);

    /**
     * initialize_graphics() is responsible for drawing the circles
     * and making the control points draggable. If you call this method,
     * make sure to retest removing points/clearing trajectory.
     * 
     * @callback 
     */
    let initialize_graphics = () => {
      this.xy_config.graphic = [];
      this.xz_config.graphic = [];

      // generate control point graphics
      for (let i = 0; i &lt; this.points.x.length; i++) {
        let graphic_template = {
          id: i,
          type: 'circle',
          $action: 'replace',
          shape: { cx: 0, cy: 0, r: 10 },
          z: 100,
          invisible: i === 0,  // show circles if you're not EE - EE has special marker from series 2
          draggable: i !== 0, // do not allow dragging of EE
          style: {
            fill: '#FFF',
            stroke: '#FF0000'
          },
          onmouseover: () => {
            let showTipAction = {
              type: 'showTip',
              seriesIndex: 0, // the control points will always be at index 0
              dataIndex: i
            };
            this.xy_plot.dispatchAction(showTipAction);
            this.xz_plot.dispatchAction(showTipAction);
          },
          onmouseout: () => {
            let hideTipAction = { type: 'hideTip' };
            this.xy_plot.dispatchAction(hideTipAction);
            this.xz_plot.dispatchAction(hideTipAction);
          }
        };

        let xy_graphic = {
          ...graphic_template,
          position: this.xy_plot.convertToPixel('grid', [this.points.x[i], this.points.y[i]]),
          ondrag: params => {
            let pt = this.xy_plot.convertFromPixel('grid', params.target.position);
            this.points.x[i] = pt[0];
            this.points.y[i] = pt[1];
            initialize_graphics();
            this.xy_plot.setOption(this.xy_config);
            this.xz_plot.setOption(this.xz_config);
          }
        };

        let xz_graphic = {
          ...graphic_template,
          position: this.xz_plot.convertToPixel('grid', [this.points.x[i], this.points.z[i]]),
          ondrag: params => {
            let pt = this.xz_plot.convertFromPixel('grid', params.target.position);
            this.points.x[i] = pt[0];
            this.points.z[i] = pt[1];
            initialize_graphics();
            this.xy_plot.setOption(this.xy_config);
            this.xz_plot.setOption(this.xz_config);
          }
        };

        this.xy_config.graphic.push(xy_graphic);
        this.xz_config.graphic.push(xz_graphic);
      }  

      // generate trajectory graphics
      for (let i = 0; i &lt; this.trajectory.x.length; i++) {
        let graphic_template = {
          type: 'circle',
          $action: 'replace',
          shape: { cx: 0, cy: 0, r: 10 },
          z: 25,
          invisible: true,
          onmouseover: () => {
            let showTipAction = {
              type: 'showTip',
              seriesIndex: 1, // the control points will always be at index 0
              dataIndex: i
            };
            this.xy_plot.dispatchAction(showTipAction);
            this.xz_plot.dispatchAction(showTipAction);
          },
          onmouseout: () => {
            let hideTipAction = { type: 'hideTip' };
            this.xy_plot.dispatchAction(hideTipAction);
            this.xz_plot.dispatchAction(hideTipAction);
          }
        };

        let xy_graphic = {
          ...graphic_template,
          position: this.xy_plot.convertToPixel('grid', [this.trajectory.x[i], this.trajectory.y[i]]),
        };

        let xz_graphic = {
          ...graphic_template,
          position: this.xz_plot.convertToPixel('grid', [this.trajectory.x[i], this.trajectory.z[i]]),
        };

        this.xy_config.graphic.push(xy_graphic);
        this.xz_config.graphic.push(xz_graphic);
      }  
    };

    // set up event listeners
    registerWindowResizeCallback(() => {
      this.xy_plot.resize();
      this.xz_plot.resize();
      initialize_graphics();
      this.xy_plot.setOption(this.xy_config);
      this.xz_plot.setOption(this.xz_config);
    });

    addPointButton.onclick = () => {
      this.points.x.push((xLim[0] + xLim[1]) / 2);
      this.points.y.push((yLim[0] + yLim[1]) / 2);
      this.points.z.push((zLim[0] + zLim[1]) / 2);
      this.points.idx.push(this.next_point_index);

      initialize_graphics();
      this.xy_plot.setOption(this.xy_config);
      this.xz_plot.setOption(this.xz_config);

      let opt = document.createElement('option');
      opt.value = this.next_point_index;
      opt.innerHTML = 'Point ' + opt.value;
      opt.selected = true;
      pointSelect.append(opt);
      $('.point-remover').trigger("chosen:updated");

      this.next_point_index++;
    };

    getTrajectoryButton.onclick = () => {
      let tf = parseFloat(trajectoryMaxTimeInput.value);
      let t_step = parseFloat(trajectoryStepSizeInput.value);

      if (t_step > tf || !t_step || !tf) {
        errorMessageLabel.innerHTML = 'Bad trajectory final time or timestep.';
        return;
      }

      errorMessageLabel.innerHTML = '';

      // collect points
      let points = [this.points.x, this.points.y, this.points.z];
      let fetchOptions = {
        method: 'POST',
        headers: new Headers({'Content-Type': 'application/json'}),
        mode: 'same-origin',
        body: JSON.stringify({tf, t_step, points})
      };

      fetch('/trajectory/generate', fetchOptions)
        .then(response => response.json())
        .then(data => {
          this.trajectory.x = data.pos[0];
          this.trajectory.y = data.pos[1];
          this.trajectory.z = data.pos[2];
          this.trajectory.t = data.time;
          this.trajectory.v = data.vel;
          this.trajectory.a = data.accel;

          // set max accel/vel UI elements
          maxAccelNorm.innerHTML = data.max_accel.norm.toExponential(3);
          maxAccelX.innerHTML = data.max_accel.x.toExponential(3);
          maxAccelY.innerHTML = data.max_accel.y.toExponential(3);
          maxAccelZ.innerHTML = data.max_accel.z.toExponential(3);
          maxVelNorm.innerHTML = data.max_vel.norm.toExponential(3);
          maxVelX.innerHTML = data.max_vel.x.toExponential(3);
          maxVelY.innerHTML = data.max_vel.y.toExponential(3);
          maxVelZ.innerHTML = data.max_vel.z.toExponential(3);

          // reset draggable
          initialize_graphics();
          this.xy_plot.setOption(this.xy_config);
          this.xz_plot.setOption(this.xz_config);
        });
    };

    let _trajectory_running = false;
    runTrajectoryButton.className = 'button-enable';
    runTrajectoryButton.onclick = () => {
      // NOTE: we have the server recompute trajectory
      let tf = parseFloat(trajectoryMaxTimeInput.value);
      let t_step = parseFloat(trajectoryStepSizeInput.value);

      if (t_step > tf || !t_step || !tf) {
        errorMessageLabel.innerHTML = 'Bad trajectory final time / timestep';
        return;
      }

      errorMessageLabel.innerHTML = '';

      // collect points
      let points = [this.points.x, this.points.y, this.points.z];
      let fetchOptions = {
        method: 'POST',
        headers: new Headers({'Content-Type': 'application/json'}),
        mode: 'same-origin',
        body: JSON.stringify({
          tf, t_step, points, // things needed for trajectory gen
          primitive_key, primitive_value, position_key, velocity_key
        })
      };

      let running_callback = () => {
        // poll repeatedly to get ee_pos &amp; status
        // clear both polling timers once complete
        let ee_pos_poll_id = setInterval(() => {
          get_redis_val(current_ee_pos_key).then(data => {
            this.ee_pos.x[0] = data[0];
            this.ee_pos.y[0] = data[1];
            this.ee_pos.z[0] = data[2];
            this.xy_plot.setOption(this.xy_config);
            this.xz_plot.setOption(this.xz_config);
          });
        }, t_step / 3);

        let id = setInterval(() => {
          let poll_fetch_options = {
            method: 'GET',
            headers: new Headers({'Content-Type': 'application/json'}),
            mode: 'same-origin'
          };

          fetch('/trajectory/run/status', poll_fetch_options)
            .then(response => response.json())
            .then(data => {
              if (!data.running) {
                clearTimeout(id);
                clearTimeout(ee_pos_poll_id);

                // now that trajectory is finished, update this.point with new ee pos
                this.points.x[0] = this.ee_pos.x[0];
                this.points.y[0] = this.ee_pos.y[0];
                this.points.z[0] = this.ee_pos.z[0];
                this.xy_plot.setOption(this.xy_config);
                this.xz_plot.setOption(this.xz_config);

                _trajectory_running = false;
                runTrajectoryButton.innerHTML = 'Start Trajectory';
                runTrajectoryButton.className = 'button-enable';
              }
            });
        }, tf / 10);
      };

      // update state &amp; UI
      _trajectory_running = !_trajectory_running;

      if (_trajectory_running) {
        runTrajectoryButton.className = 'button-disable';
        runTrajectoryButton.innerHTML = 'Stop Trajectory';
        fetch('/trajectory/run', fetchOptions)
          .then(() => running_callback())
          .catch(error => {
            errorMessageLabel.innerHTML = 'Trajectory execution failed: ' + toString(error);
          }
        );
      } else {
        fetch('/trajectory/run/stop', fetchOptions)
          .then(response => {
            if (response.ok)
              _trajectory_running = false;
          });
      }
    };

    clearTrajectoryButton.onclick = () => {
      this.trajectory.x.length = 0;
      this.trajectory.y.length = 0;
      this.trajectory.z.length = 0;
      this.trajectory.t.length = 0;
      this.trajectory.v.length = 0;
      this.xy_plot.setOption(this.xy_config);
      this.xz_plot.setOption(this.xz_config);
    }

    pointSelect.onchange = e => {
      let options = [];
      for (let option of e.target.selectedOptions) {
        options.push(parseInt(option.value));
      }

      // work on all points not the EE pos
      for (let i = this.points.idx.length - 1; i >= 1; i--) {
        if (options.includes(this.points.idx[i]))
          continue;
        
        // instruct echarts to remove the appropriate draggable element
        this.xy_config.graphic[i].$action = 'remove'; 
        this.xz_config.graphic[i].$action = 'remove';
        this.points.x.splice(i, 1);
        this.points.y.splice(i, 1);
        this.points.z.splice(i, 1);
        this.points.idx.splice(i, 1);
      }

      this.xy_plot.setOption(this.xy_config);
      this.xz_plot.setOption(this.xz_config);
    };

    // append to document
    this.appendChild(template_node);

    // grab ee pos and initialize plot afterwards
    // goal: we want the special marker for EE pos
    // and we want a dashed line connecting the EE pos to the other control points
    // problem: EE pos is in a different series than the control points, so no line
    // solution: we have the EE pos in series 2 with special marker, but make an invisible
    //  point in series 0 (control points) right on the EE pos to get the dashed line.
    get_redis_val(current_ee_pos_key).then(data => {
      this.ee_pos.x[0] = data[0];
      this.ee_pos.y[0] = data[1];
      this.ee_pos.z[0] = data[2];
      this.points.x.push(data[0]);
      this.points.y.push(data[1]);
      this.points.z.push(data[2]);
      this.points.idx.push(0);
      initialize_graphics();
      this.xy_plot.setOption(this.xy_config);
      this.xz_plot.setOption(this.xz_config);
      this.xy_plot.resize();
      this.xz_plot.resize();  
    });
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-._const.html">./const</a></li><li><a href="module-._module_sai2-interface-display.html">./module/sai2-interface-display</a></li><li><a href="module-._module_sai2-interface-enum.html">./module/sai2-interface-enum</a></li><li><a href="module-._module_sai2-interface-logger.html">./module/sai2-interface-logger</a></li><li><a href="module-._module_sai2-interface-plot.html">./module/sai2-interface-plot</a></li><li><a href="module-._module_sai2-interface-select.html">./module/sai2-interface-select</a></li><li><a href="module-._module_sai2-interface-slider.html">./module/sai2-interface-slider</a></li><li><a href="module-._module_sai2-interface-toggle.html">./module/sai2-interface-toggle</a></li><li><a href="module-._module_sai2-interface-trajectory-slider.html">./module/sai2-interface-trajectory-slider</a></li><li><a href="module-._redis.html">./redis</a></li><li><a href="module-._resize.html">./resize</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Wed Jul 24 2019 21:46:59 GMT-0700 (PDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
